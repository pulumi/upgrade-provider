package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

const (
	maxInputs  = 8
	maxOutputs = 8
)

func main() {
	var b bytes.Buffer
	fmt.Fprintf(&b, `// Code generated by calls.go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package step

// This file contains Call${I}${O} and Call${I}${O}E implementations for I=0..%d, O=0..%d.
//
// This represents a function call with I inputs and O returned values. If there is an E at
// the end of the Call: Call00E, then there is an additional expected error in the passed
// through function.

import "context"

`, maxInputs, maxOutputs)
	for in := 0; in < maxInputs; in++ {
		for out := 0; out < maxOutputs; out++ {
			exitOnError(call(&b, in, out))
		}
	}

	exitOnError(os.WriteFile("calls.go", b.Bytes(), 0600))
}

func exitOnError(err error) {
	if err == nil {
		return
	}
	fmt.Printf("error: %s", err.Error())
	os.Exit(1)
}

func call(w io.Writer, in, out int) error {
	genericTypeArr := make([]string, in+out)
	var namedInputs string
	var inputTypes string
	inputsArr := make([]string, in)
	for i := 0; i < in; i++ {
		genericTypeArr[i] = fmt.Sprintf("I%d any", i+1)
		namedInputs += fmt.Sprintf(", i%[1]d I%[1]d", i+1)
		inputTypes += fmt.Sprintf(", I%d", i+1)
		inputsArr[i] = fmt.Sprintf("i%d", i+1)
	}
	outputTypeArr := make([]string, out)
	var outputsArr = make([]string, out)
	for i := 0; i < out; i++ {
		genericTypeArr[i+in] = fmt.Sprintf("O%d any", i+1)
		outputTypeArr[i] = fmt.Sprintf("O%d", i+1)
		outputsArr[i] = fmt.Sprintf("o%d", i+1)

	}
	outputTypes := strings.Join(outputTypeArr, ", ")
	if out > 1 {
		outputTypes = "(" + outputTypes + ")"
	}
	if out > 0 {
		outputTypes = " " + outputTypes
	}
	var outputTypesWithErr string
	if out == 0 {
		outputTypesWithErr = "error"
	} else {
		outputTypesWithErr = "(" + strings.Join(outputTypeArr, ", ") + ", error)"
	}

	var genericTypes string
	if in+out > 0 {
		genericTypes = "[" + strings.Join(genericTypeArr, ", ") + "]"
	}

	var retCall, retF, retErrorValue, retNoOutputs string
	if out > 0 {
		retCall = "return "
		retF = strings.Join(outputsArr, ", ") + " := "
		retErrorValue = "\n\t\treturn " + strings.Join(outputsArr, ", ") + ", nil"
	} else {
		retNoOutputs = "\n\t\treturn nil"
	}

	var inputArgs string
	if in > 0 {
		inputArgs = ", " + strings.Join(inputsArr, ", ")
	}

	f := fmt.Sprintf(`func Call%d%d%s(ctx context.Context, name string, f func(context.Context%s)%s%s)%s {
	%sCall%d%dE(ctx, name, func(ctx context.Context%s) %s {
		%sf(ctx%s)%s%s
	}%s)
}

`, in, out, genericTypes, inputTypes, outputTypes, namedInputs, outputTypes,
		retCall, in, out, namedInputs, outputTypesWithErr,
		retF, inputArgs, retErrorValue, retNoOutputs,
		inputArgs,
	)
	_, err := w.Write([]byte(f))
	if err != nil {
		return err
	}

	retValuesArr := make([]string, out)
	for i := 0; i < out; i++ {
		retValuesArr[i] = fmt.Sprintf("outputs[%d].(O%d)", i, i+1)
	}
	retValues := strings.Join(retValuesArr, ", ")
	if out > 0 {
		retValues = " " + retValues
	}

	fE := fmt.Sprintf(`func Call%d%dE%s(ctx context.Context, name string, f func(context.Context%s)%s%s) %s {
	inputs := []any{%s}
	outputs := make([]any, %d)
	run(ctx, name, f, inputs, outputs)
	return%s
}

`, in, out, genericTypes, inputTypes, outputTypesWithErr, namedInputs, outputTypes,
		strings.Join(inputsArr, ", "),
		out+1, // +1 for the returned error value
		retValues)

	_, err = w.Write([]byte(fE))
	return err
}
