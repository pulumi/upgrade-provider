package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

const (
	maxInputs  = 8
	maxOutputs = 8
)

func main() {
	var b bytes.Buffer
	fmt.Fprintf(&b, `// Code generated by calls.go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package step

// This file contains Call${I}${O} and Call${I}${O}E implementations for I=0..%d, O=0..%d.
//
// This represents a function call with I inputs and O returned values. If there is an E at
// the end of the Call: Call00E, then there is an additional expected error in the passed
// through function.

import "context"

`, maxInputs, maxOutputs)
	for in := 0; in < maxInputs; in++ {
		for out := 0; out < maxOutputs; out++ {
			exitOnError(call(&b, in, out))
		}
	}

	exitOnError(os.WriteFile("calls.go", b.Bytes(), 0600))
}

func exitOnError(err error) {
	if err == nil {
		return
	}
	fmt.Printf("error: %s", err.Error())
	os.Exit(1)
}

func call(w io.Writer, in, out int) error {
	t := types{in, out}
	genericTypes := t.fullTypeList()

	inputsArr := t.argListFmt("i%d")
	inputTypes := strings.Join(t.argListFmt(", I%d"), "")
	namedInputs := strings.Join(t.argListFmt(", i%[1]d I%[1]d"), "")

	var inputArgs string
	if in > 0 {
		inputArgs = ", " + strings.Join(inputsArr, ", ")
	}

	outputTypeArr := t.retListFmt("O%d")
	outputsArr := t.retListFmt("o%d")

	outputTypes := strings.Join(outputTypeArr, ", ")
	if out > 1 {
		outputTypes = "(" + outputTypes + ")"
	}
	if out > 0 {
		outputTypes = " " + outputTypes
	}
	var outputTypesWithErr string
	if out == 0 {
		outputTypesWithErr = "error"
	} else {
		outputTypesWithErr = "(" + strings.Join(outputTypeArr, ", ") + ", error)"
	}

	var retCall, retF, retErrorValue, retNoOutputs string
	if out > 0 {
		retCall = "return "
		retF = strings.Join(outputsArr, ", ") + " := "
		retErrorValue = "\n\t\treturn " + strings.Join(outputsArr, ", ") + ", nil"
	} else {
		retNoOutputs = "\n\t\treturn nil"
	}

	_, err := fmt.Fprintf(w, `func Call%d%d%s(ctx context.Context, name string, f func(context.Context%s)%s%s)%s {
	%sCall%d%dE(ctx, name, func(ctx context.Context%s) %s {
		%sf(ctx%s)%s%s
	}%s)
}

`, in, out, genericTypes, inputTypes, outputTypes, namedInputs, outputTypes,
		retCall, in, out, namedInputs, outputTypesWithErr,
		retF, inputArgs, retErrorValue, retNoOutputs,
		inputArgs,
	)
	if err != nil {
		return err
	}

	retValuesArr := make([]string, out)
	for i := 0; i < out; i++ {
		retValuesArr[i] = fmt.Sprintf("outputs[%d].(O%d)", i, i+1)
	}
	retValues := strings.Join(retValuesArr, ", ")
	if out > 0 {
		retValues = " " + retValues
	}

	_, err = fmt.Fprintf(w, `func Call%d%dE%s(ctx context.Context, name string, f func(context.Context%s)%s%s) %s {
	inputs := []any{%s}
	outputs := make([]any, %d)
	run(ctx, name, f, inputs, outputs)
	return%s
}

`, in, out, genericTypes, inputTypes, outputTypesWithErr, namedInputs, outputTypes,
		strings.Join(inputsArr, ", "),
		out+1, // +1 for the returned error value
		retValues)

	return err
}

type types struct{ in, out int }

func (a types) argListFmt(in string) []string {
	elems := make([]string, 0, a.in)
	for i := 1; i <= a.in; i++ {
		elems = append(elems, fmt.Sprintf(in, i))
	}
	return elems
}

func (a types) retListFmt(out string) []string {
	elems := make([]string, 0, a.out)
	for i := 1; i <= a.out; i++ {
		elems = append(elems, fmt.Sprintf(out, i))
	}
	return elems
}

func (a types) fullTypeList() string {
	if a.in+a.out == 0 {
		return ""
	}
	ins := a.argListFmt("I%d any")
	outs := a.retListFmt("O%d any")
	return "[" + strings.Join(append(ins, outs...), ", ") + "]"
}
