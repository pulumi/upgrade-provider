package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

const (
	maxInputs  = 8
	maxOutputs = 8
)

func main() {
	var b bytes.Buffer
	fmt.Fprintf(&b, `// Code generated by calls.go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package step

// This file contains Call${I}${O} and Call${I}${O}E implementations for I=0..%d, O=0..%d.
//
// This represents a function call with I inputs and O returned values. If there is an E at
// the end of the Call: Call00E, then there is an additional expected error in the passed
// through function.

import "context"

`, maxInputs, maxOutputs)
	for in := 0; in < maxInputs; in++ {
		for out := 0; out < maxOutputs; out++ {
			exitOnError(call(&b, in, out))
		}
	}

	exitOnError(os.WriteFile("calls.go", b.Bytes(), 0600))
}

func exitOnError(err error) {
	if err == nil {
		return
	}
	fmt.Printf("error: %s", err.Error())
	os.Exit(1)
}

func call(w io.Writer, in, out int) error {
	fprintf := func(format string, a ...any) {
		_, err := fmt.Fprintf(w, format, a...)
		if err != nil {
			panic(err)
		}
	}
	t := types{in, out}
	genericTypes := t.fullTypeList()

	inputsArr := t.argListFmt("i%d")
	inputTypes := strings.Join(t.argListFmt(", I%d"), "")
	namedInputs := strings.Join(t.argListFmt(", i%[1]d I%[1]d"), "")

	var inputArgs string
	if in > 0 {
		inputArgs = ", " + strings.Join(inputsArr, ", ")
	}

	outputTypeArr := t.retListFmt("O%d")
	outputsArr := t.retListFmt("o%d")

	outputTypes := strings.Join(outputTypeArr, ", ")
	if out > 1 {
		outputTypes = "(" + outputTypes + ")"
	}
	if out > 0 {
		outputTypes = " " + outputTypes
	}
	var outputTypesWithErr string
	if out == 0 {
		outputTypesWithErr = " error"
	} else {
		outputTypesWithErr = " (" + strings.Join(outputTypeArr, ", ") + ", error)"
	}

	retValuesArr := make([]string, out)
	for i := 0; i < out; i++ {
		retValuesArr[i] = fmt.Sprintf("cast[O%d](outputs[%d])", i+1, i)
	}
	retValues := strings.Join(retValuesArr, ", ")
	if out > 0 {
		retValues = " " + retValues
	}

	signature := func(name, output string) {
		fprintf(`func %s%s(name string, f func(context.Context%s)%s) func(context.Context%s)%s {`,
			name, genericTypes, inputTypes, output, inputTypes, outputTypes)
	}

	var thump string
	if out > 0 {
		thump = fmt.Sprintf("%s := f(ctx%s)\n\t\treturn %[1]s, nil",
			strings.Join(outputsArr, ", "), inputArgs)
	} else {
		thump = fmt.Sprintf("f(ctx%s)\n\t\treturn nil", inputArgs)
	}

	// Write out the signature for the Func__ variant
	signature(t.funcName(false), outputTypes)
	fprintf(`
	return %s(name, func(ctx context.Context%s)%s {
		%s
	})`,
		t.funcName(true), namedInputs, outputTypesWithErr,
		thump,
	)
	fprintf("\n}\n\n")

	// Write out the signature for the Func__E variant
	signature(t.funcName(true), outputTypesWithErr)

	// Write the returned inner function
	fprintf(`
	return func(ctx context.Context%s)%s {
		inputs := []any{%s}
		outputs := make([]any, %d)
		run(ctx, name, f, inputs, outputs)
		return%s
	}`, namedInputs, outputTypes,
		strings.Join(inputsArr, ", "),
		out+1,
		retValues,
	)

	// Close the function
	fprintf("\n}\n\n")
	return nil
}

type types struct{ in, out int }

func (a types) funcName(err bool) string {
	s := fmt.Sprintf("Func%d%d", a.in, a.out)
	if err {
		s += "E"
	}
	return s
}

func (a types) argListFmt(in string) []string {
	elems := make([]string, 0, a.in)
	for i := 1; i <= a.in; i++ {
		elems = append(elems, fmt.Sprintf(in, i))
	}
	return elems
}

func (a types) retListFmt(out string) []string {
	elems := make([]string, 0, a.out)
	for i := 1; i <= a.out; i++ {
		elems = append(elems, fmt.Sprintf(out, i))
	}
	return elems
}

func (a types) fullTypeList() string {
	if a.in+a.out == 0 {
		return ""
	}
	ins := a.argListFmt("I%d any")
	outs := a.retListFmt("O%d any")
	return "[" + strings.Join(append(ins, outs...), ", ") + "]"
}
